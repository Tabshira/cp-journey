//Sieve of Eratosthenes (check prime)
  vector<bool> isPrime(n+1,1);
  isPrime[0]=isPrime[1]=0;
  for(int i=2;i*i<=n;i++)
  {
      if(isPrime[i]==1)
      {
          for(int j=i*i;j<=n;j+=i)
          {
              isPrime[j]=0;
          }
      }
  }

//NOD Sieve
  vector<int> divisors(n+1,0);
  for(int i=1;i<=n;i++)
  {
    for(int j=i;j<=n;j+=i)
          {
              divisors[j]++;
          }
  }

//SOD sieve
  vector<int> SOD(n+1,1);
  for(int i=2;i<=n;i++)
  {
    for(int j=i;j<=n;j+=i)
          {
              SOD[j]+=i;
          }
  }

  ////GCD
  int a,b;
  cin>>a>>b;

  //first
  while(a>0)
  {
      int past_a=a;
      int past_b=b;
      a=past_b%past_a;
      b=past_a;
  }
  cout<<b<<endl;

//recursive
int gcd(int a,int b)
  {
      if(a==0) return b;
      else
        return gcd(b%a,a);
  }

//Inbuilt Function
int ans=__gcd(a,b);

//LCM
a*b=gcd(a,b)*lcm(a,b)
int lcm=(a*b)/gcd(a,b);

//Prefix
 prefix[0] = ar[0]; //initializing first element
  for (int i = 1; i < 5; i++) {
    prefix[i] = prefix[i - 1] + ar[i];
  }
 Given an array of n integers, find if any index exists such that the sum of elements to its right is equal to the sum of elements to its left.
If yes print the index, otherwise print “No Equilibrium”.
soln:
long long leftsum=0;
    long long totalsum=accumulate(A.begin(),A.end(),0LL);
    for(int i=0;i<N;i++)
    {
        long long rightsum=totalsum-leftsum-A[i];
        if(leftsum==rightsum)
        {
            cout<<i<<endl;
            return 0;
        }
        leftsum+=A[i];
    }
    cout<<"No Equilibrium"<<endl;
